{"./":{"url":"./","title":"Introduction","keywords":"","body":"Mirroreaプロジェクトにようこそ。 ここでは，同期に特化した言語「Mir言語」と，その上で動作するシステム「Mirrorea」についてのアイデアを記述してあります。 まだα版ですので，考えが至っていない点や無秩序な記述があるかと思いますが，少しずつ改善していきたいと考えています。 よろしくお願いします。 "},"concept/01_introduction.html":{"url":"concept/01_introduction.html","title":"はじめに","keywords":"","body":"はじめに TODO: ここに直観を書いていく TODO: 全体像が分かっていない状態において，実は概要というものが一番書きづらいので，最後に書きます。 "},"concept/02_basics.html":{"url":"concept/02_basics.html","title":"Mir言語の基本概念","keywords":"","body":"Mir言語の基本概念 Mir言語の本質は以下の２点に集約されます。 一つの機能は一括で記述すること。 値やノードの依存関係を非巡回にすること。 つまり，複数ノードから成るシステムを記述するための言語として設計されています。 1. 一つの機能は一括で記述すること 複数の計算機がネットワーク越しに通信し合うようなシステムを組む際，通信用のインターフェースを取り決めた後に実装をすることになると思います。 でもそれは（WebAPI等の開かれたシステム以外では）実装の結果生まれた物であることが多く，早すぎる具体化なのではないでしょうか。 例えば，以下のような処理をするシステムを考えます。 Aが情報を投げる サーバで検査し中継する Bが受け取り実行 従来のプログラミング言語で疑似コードで表すと，概ね以下のような書き心地になるのではないでしょうか。 このように，ノードごとに処理を書く際の問題点として， ロジックが複数個所に分散する 寿命管理が困難になる モジュール同士の依存管理が困難になる などが挙げられます。 そこで，以下のように記述できる言語を考えます。 NodeA [ let val = calc(); Server [ if(validate(val)){ NodeB [ exec(val); ] } ] ] このコードの本質的な処理内容を抜き出すと，システム全体が本来持つ処理内容を端的に表せていることが分かります。 let val = calc(); if(validate(val)){ exec(val); } この処理を実際に各ノード上で実行するには，「どのノードで実行されるか」という情報が必要になります。 そこで登場するのが Node[] 表記です。 コードの各部分について「どこのノードで実行するのか」を注記することで，情報の所在や発生する通信について，同時に定義できます。 もっと実践的な例を考えてみましょう。 例えば，サーバ（Sとします）に2つのクライアント（それぞれA,Bとします）が接続しているゲームを考えます。 このゲーム上で「AがBを攻撃した」という処理を行うとき，システムとしては「b.hp -= a.attack_power」という処理が行われます。 この際，処理が行われる場所について，例えば以下のようなものが考えられます ステータス管理も攻撃処理もサーバで行う Aからサーバに，攻撃したことを報告する サーバから全体に，新たなBのHPを報告する ステータス管理は各個人で行い，攻撃処理は被攻撃者が行う Aからサーバに，攻撃したことと，その攻撃力を報告する サーバからBに，攻撃を受けたことと，その攻撃力を報告する Bは，減算後のHPをサーバに報告する ステータス管理は各個人で行い，攻撃処理は攻撃者が行う Aから全体に，Bの新たなHPを報告する 先ほどの表記法で書き直してみると，それぞれ以下のようになりそうです。 S[b.hp -= a.attack_power] B[b.hp -= A[a.attack_power]] A[ b.hp -= a.attack_power ] ここで生じる疑問として，3つ目の処理において「Aから全体に通知をする」という処理がここから導けないのではないかと気づくことでしょう。 これらの計算結果を誰が管理し，各ノードがどのように取得するのかについては，後ほど議論します。（この文章を書いている時点ではどこの章で書くかは未定です） ともあれ，各変数の単位（誰に対して定義されているか）と，その所有者（変数の問い合わせ先）を定義する必要があります。 この二つは同じものに見えるかもしれませんが，例えば「クライアントの人数分，サーバ側で保持する変数」といった物も考えられます。 では，ここまでを纏めて，疑似的なコードを書いてみます。 Network { S -> { A, B } } struct Player { int hp; int atk; } ケース1： ステータス管理も攻撃処理もサーバで行う S[ [A] Player a; [B] Player b; ] A[ when A.attack { S[ b.hp -= a.atk ]; } ] ケース2： ステータス管理は各個人で行い，攻撃処理は被攻撃者が行う A[ Player a; ] B[ Player b; ] A[ when A.attack { B[ b.hp -= a.atk ]; } ] ケース3： ステータス管理は各個人で行い，攻撃処理は攻撃者が行う A[ Player a; ] B[ Player b; ] A[ when A.attack { b.hp -= a.atk } ] 2. 値やノードの依存関係を非巡回にすること イベント駆動のシステムにおいて，システムは「状態」を持ちます。 その中の1つの状態だけを見ると，基本的に各値は他の値に依存して決まっていると思います。 Mir言語では，この値同士の依存関係と，さらにはノード同士の依存関係に循環が無いことを要求します。 ここで言う値同士の依存関係の定義は「依存先の値が全て生きていれば，その時に限り，依存元の値が参照可能であること」であり，ノード同士の依存関係の定義は「依存先が全て揃っていれば，その時に限り，ノードがシステムに参加でき，システムの一部として動作できること」です。 つまり，正しい順番であれば起動中にノードを1つずつ追加・削除できることを前提としています。 イメージをつけてもらうため，まずは値同士の依存グラフを考えます。 ただしこの依存は単に計算する際に発生する物ではなく，値への参照を保持している際に発生する物だという点に注意してください。 Mir言語の基本概念1. 一つの機能は一括で記述すること2. 値やノードの依存関係を非巡回にすること"},"concept/03_typing.html":{"url":"concept/03_typing.html","title":"型と効果のシステム","keywords":"","body":"型と効果のシステム "},"concept/04_consistency.html":{"url":"concept/04_consistency.html","title":"分散とアトミック","keywords":"","body":"分散とアトミック "},"concept/05_example.html":{"url":"concept/05_example.html","title":"プログラム例","keywords":"","body":"プログラム例 "},"concept/06_verification.html":{"url":"concept/06_verification.html","title":"形式検証","keywords":"","body":"形式検証 "},"concept/07_internet_system.html":{"url":"concept/07_internet_system.html","title":"開かれたインターネットシステム","keywords":"","body":"開かれたインターネットシステム "}}